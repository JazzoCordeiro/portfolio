<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Componentes</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../artigos.css">
</head>
<body>
    <header class="header">
        <div id="header-placeholder"></div>
        <script> fetch('../header-pt2.html').then(response => response.text()).then(data => {
                document.getElementById('header-placeholder').innerHTML = data; initializeThemeSwitcher(); // Chama a função para inicializar o botão de modo
            }); function initializeThemeSwitcher() {
                let trilho = document.getElementById('trilho'); if (!trilho) { console.error('Elemento "trilho" não encontrado'); return; } let body = document.querySelector('body'); let header = document.querySelector('.header'); let tooltips = document.querySelectorAll('.tooltip'); // Verificar se o modo claro foi salvo no localStorage e aplicá-lo
                if (localStorage.getItem('theme') === 'light') { body.classList.add('light'); header.classList.add('light'); trilho.classList.add('light'); tooltips.forEach(function (tooltip) { tooltip.classList.add('light'); }); } // Alterna entre o modo normal e o modo claro
                trilho.addEventListener('click', function () {
                    trilho.classList.toggle('light'); body.classList.toggle('light'); header.classList.toggle('light'); tooltips.forEach(function (tooltip) { tooltip.classList.toggle('light'); }); // Salva a preferência no localStorage (modo claro ou normal)
                    if (body.classList.contains('light')) { localStorage.setItem('theme', 'light'); } else { localStorage.removeItem('theme'); }
                });
            } </script>
    </header>
    <main>

        <h1 class="titulo">O que é a Componentização no Frontend e Como Funciona?</h1>

        <p class="comum"><strong>Componentização</strong> no contexto do desenvolvimento frontend refere-se ao processo de dividir uma interface de usuário (UI) em partes menores e reutilizáveis chamadas <strong>componentes</strong>. Cada componente é responsável por uma parte específica da UI, tornando o código mais fácil de manter, reutilizar e organizar.</p>
    
        <h2 class="subtitulo">Como Funciona a Componentização?</h2>
        <p class="comum">Os componentes são unidades independentes e isoladas que podem ser combinadas para formar uma interface mais complexa. Cada componente pode ter seu próprio estado, comportamento e estilo. Além disso, os componentes podem ser reutilizados ao longo da aplicação, promovendo a <strong>modularização</strong> do código.</p>
    
        <h3>Principais Conceitos de Como a Componentização Funciona:</h3>
        <ul class="lista">
            <li class="especifico"><strong>Separação de Responsabilidades</strong>: Cada componente tem uma responsabilidade específica, como um botão, formulário ou cartão. Ele é projetado para realizar uma tarefa ou representar uma parte da UI de forma isolada.</li>
            <li class="especifico"><strong>Reusabilidade</strong>: Os componentes podem ser reutilizados em diferentes partes da aplicação. Isso economiza tempo e esforço, além de evitar duplicação de código. Por exemplo, se você precisar de um botão em várias páginas, pode criar um único componente de botão e usá-lo em diversos lugares.</li>
            <li class="especifico"><strong>Composição de Componentes</strong>: Com a componentização, você pode compor componentes menores para formar interfaces maiores e mais complexas. Por exemplo, um <strong>cartão de produto</strong> pode ser composto por um <strong>título</strong>, uma <strong>imagem</strong> e um <strong>botão</strong>, sendo cada um um componente individual.</li>
            <li class="especifico"><strong>Isolamento de Estado e Lógica</strong>: Cada componente pode gerenciar seu próprio estado, ou seja, ele pode ter variáveis internas que controlam seu comportamento (por exemplo, a visibilidade de um menu ou o conteúdo exibido). Em aplicações mais complexas, a comunicação entre componentes pode ser feita através de <strong>props</strong> ou <strong>eventos</strong>.</li>
            <li class="especifico"><strong>Facilidade de Manutenção e Escalabilidade</strong>: A componentização facilita a manutenção do código, pois cada parte da interface é isolada e pode ser modificada sem afetar outras partes. Além disso, torna a aplicação mais escalável, pois é mais fácil adicionar novos componentes sem quebrar os existentes.</li>
        </ul>
    
        <h2 class="subtitulo">Vantagens da Componentização</h2>
        <ul class="lista">
            <li class="especifico"><strong>Reusabilidade</strong>: Os componentes podem ser usados em diferentes partes da aplicação sem a necessidade de duplicar código.</li>
            <li class="especifico"><strong>Organização</strong>: A aplicação se torna mais organizada, pois cada componente tem uma função bem definida.</li>
            <li class="especifico"><strong>Facilidade de Manutenção</strong>: Alterações em um componente afetam apenas esse componente, tornando a manutenção mais fácil.</li>
            <li class="especifico"><strong>Facilidade de Testes</strong>: Como os componentes são isolados, é mais fácil testar cada parte da interface separadamente.</li>
        </ul>
    </main>
    <footer class="footer">

        <div id="footer-placeholder"></div>
        <script src="main.js"></script>
        <script>
            fetch('../footer.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('footer-placeholder').innerHTML = data;
                });
        </script>
    </footer>
</body>
</html>
